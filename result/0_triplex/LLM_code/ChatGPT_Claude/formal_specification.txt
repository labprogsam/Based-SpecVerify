[triplex_12B_code_analysis.txt]

1. State Variable Mapping
- Persistent state (UnitDelay)
  - rtDW.Delay1_DSTATE[0]
    - Possible values: int32_T >= 0
    - Meaning: Previous-cycle Persistence Count (PC_prev)
  - rtDW.Delay1_DSTATE[1]
    - Possible values: int32_T >= 0
    - Meaning: Previous-cycle Totalizer Count (TC_prev)
  - rtDW.Delay1_DSTATE[2]
    - Possible values: {0,1,2,4}
    - Meaning: Previous-cycle Latched Fault Code (FC_prev)
- Next-state buffer (computed each cycle by the monitor logic)
  - rtDW.Merge_e[0]
    - Possible values: int32_T >= 0
    - Meaning: Current-cycle PC to be output and committed to UnitDelay at end of cycle
  - rtDW.Merge_e[1]
    - Possible values: int32_T >= 0
    - Meaning: Current-cycle TC to be output and committed to UnitDelay at end of cycle
  - rtDW.Merge_e[2]
    - Possible values: {0,1,2,4}
    - Meaning: Current-cycle FC to be output and committed to UnitDelay at end of cycle
- Selected value accumulator (non-persistent within cycle)
  - rtDW.Merge
    - Possible values: double
    - Meaning: Current-cycle selected value (drives rtY.sel_val)
- External inputs (System external names from code)
  - rtU.ia, rtU.ib, rtU.ic: double
  - rtU.Tlevel: double
  - rtU.PClimit: int32_T
- External outputs (System external names from code)
  - rtY.PC: int32_T, equals rtDW.Merge_e[0]
  - rtY.TC: int32_T, equals rtDW.Merge_e[1]
  - rtY.FC: int32_T, equals rtDW.Merge_e[2]
  - rtY.sel_val: double, equals rtDW.Merge

State transitions and conditions (from triplex_12B_step)
- Read UnitDelay at start of cycle:
  - rtb_Delay1_idx_0 = rtDW.Delay1_DSTATE[0] (PC_prev)
  - rtb_Delay1_idx_1 = rtDW.Delay1_DSTATE[1] (TC_prev)
  - rtb_Delay1_idx_2 = rtDW.Delay1_DSTATE[2] (FC_prev)
- Miscompare booleans (true if outside trip level):
  - Rel_AB: rtb_RelationalOperator_o = (fabs(rtU.ia - rtU.ib) > rtU.Tlevel)
  - Rel_BC: rtb_RelationalOperator1 = (fabs(rtU.ib - rtU.ic) > rtU.Tlevel)
  - Rel_AC: rtb_RelationalOperator2 = (fabs(rtU.ia - rtU.ic) > rtU.Tlevel)
- “No miscompare” boolean:
  - no_mis = (!Rel_AB && !Rel_BC && !Rel_AC)
- Persistence limit boolean:
  - pc_gt_lim = (PC_prev > rtU.PClimit)
- Act1 (clear while quiet): if (PC_prev == 0) && no_mis
  - PC_next = 0; TC_next = TC_prev; FC_next = FC_prev
- Act2 (decay during quiet): else if (PC_prev > 0) && no_mis
  - PC_next = PC_prev - 1; TC_next = TC_prev; FC_next = FC_prev
- Act3 (exactly one pair miscompares): else if
  - (Rel_AB && !Rel_BC && !Rel_AC) ||
    (!Rel_AB && Rel_BC && !Rel_AC) ||
    (!Rel_AB && !Rel_BC && Rel_AC)
  - PC_next = PC_prev; TC_next = TC_prev; FC_next = FC_prev
- Else (miscompare handling, including pending/latching)
  - Identify single-branch isolation patterns:
    - A-fail pattern: Rel_AB && !Rel_BC && Rel_AC
    - B-fail pattern: Rel_AB && Rel_BC && !Rel_AC
    - C-fail pattern: !Rel_AB && Rel_BC && Rel_AC
  - Pending failure (increment PC and TC) if any pattern holds and (PC_prev <= rtU.PClimit)
    - PC_next = PC_prev + 1; TC_next = TC_prev + 1; FC_next = FC_prev
  - Latch failure (set FC and reset PC) if any pattern holds and (PC_prev > rtU.PClimit)
    - B-fail: FC_next = 2; PC_next = 0; TC_next = TC_prev
    - A-fail: FC_next = 4; PC_next = 0; TC_next = TC_prev
    - C-fail: FC_next = 1; PC_next = 0; TC_next = TC_prev
  - All-three miscompare (second-failure-in-progress surrogate in code):
    - Condition: Rel_AB && Rel_BC && Rel_AC
    - Action: PC_next = PC_prev; TC_next = TC_prev + 1; FC_next = FC_prev
- Selection (uses current-cycle FC = rtDW.Merge_e[2])
  - If FC == 0 (No-Fail): mid-value selection via mean-based two-switch method
    - m = (rtU.ia + rtU.ib + rtU.ic)/3
    - pick candidate among ia and ib closer to m; then pick between that candidate and ic, again closer to m
    - rtDW.Merge set to that value
  - If FC == 1 (Single-BranchC-Fail): rtDW.Merge = (rtU.ia + rtU.ib)/2
  - If FC == 2 (Single-BranchB-Fail): rtDW.Merge = (rtU.ia + rtU.ic)/2
  - If FC == 4 (Single-BranchA-Fail): rtDW.Merge = (rtU.ib + rtU.ic)/2
- Outputs driven within the same cycle:
  - rtY.PC = rtDW.Merge_e[0]; rtY.TC = rtDW.Merge_e[1]; rtY.FC = rtDW.Merge_e[2]; rtY.sel_val = rtDW.Merge
- UnitDelay update point (VERY IMPORTANT)
  - After the end of triplex_12B_step (global step), the UnitDelay is updated as:
    - rtDW.Delay1_DSTATE[0] = rtDW.Merge_e[0]  // PC committed after global_step()
    - rtDW.Delay1_DSTATE[1] = rtDW.Merge_e[1]  // TC committed after global_step()
    - rtDW.Delay1_DSTATE[2] = rtDW.Merge_e[2]  // FC committed after global_step()

2. Requirements
[RM-001]
- Initial conditions
  - State at cycle k-1 (after previous global step): rtDW.Delay1_DSTATE[2] (FC_prev) can be 0 or already set; This requirement targets no-fail-to-latched-first-fail behavior. In code, latching is independent of FC_prev, but the intended “no-fail” path corresponds to FC_prev == 0.
  - Counters: rtDW.Delay1_DSTATE[0] (PC_prev) arbitrary (typically 0 at onset of persistent miscompare)
- Input triggers
  - One-branch-isolating miscompare pattern sustained:
    - A-fail pattern: (fabs(rtU.ia - rtU.ib) > rtU.Tlevel) && !(fabs(rtU.ib - rtU.ic) > rtU.Tlevel) && (fabs(rtU.ia - rtU.ic) > rtU.Tlevel)
    - B-fail pattern: (fabs(rtU.ia - rtU.ib) > rtU.Tlevel) && (fabs(rtU.ib - rtU.ic) > rtU.Tlevel) && !(fabs(rtU.ia - rtU.ic) > rtU.Tlevel)
    - C-fail pattern: !(fabs(rtU.ia - rtU.ib) > rtU.Tlevel) && (fabs(rtU.ib - rtU.ic) > rtU.Tlevel) && (fabs(rtU.ia - rtU.ic) > rtU.Tlevel)
- Expected state changes
  - While the pattern holds and rtDW.Delay1_DSTATE[0] <= rtU.PClimit (pending failure):
    - rtDW.Merge_e[0] = rtDW.Delay1_DSTATE[0] + 1  // PC increments by 1
    - rtDW.Merge_e[1] = rtDW.Delay1_DSTATE[1] + 1  // TC increments by 1
    - rtDW.Merge_e[2] = rtDW.Delay1_DSTATE[2]      // FC unchanged
  - On the first cycle where the same pattern holds and rtDW.Delay1_DSTATE[0] > rtU.PClimit (persistence exceeded):
    - B-fail pattern: rtDW.Merge_e[2] = 2; rtDW.Merge_e[0] = 0; rtDW.Merge_e[1] = rtDW.Delay1_DSTATE[1]
    - A-fail pattern: rtDW.Merge_e[2] = 4; rtDW.Merge_e[0] = 0; rtDW.Merge_e[1] = rtDW.Delay1_DSTATE[1]
    - C-fail pattern: rtDW.Merge_e[2] = 1; rtDW.Merge_e[0] = 0; rtDW.Merge_e[1] = rtDW.Delay1_DSTATE[1]
  - CLEAR UnitDelay update after global_step(): rtDW.Delay1_DSTATE[...] <= rtDW.Merge_e[...]
- Output verification
  - rtY.FC shall equal 2 (B), 4 (A), or 1 (C) when the respective pattern is true and rtDW.Delay1_DSTATE[0] > rtU.PClimit at the start of the cycle.
  - rtY.PC shall be 0 on the latch cycle; rtY.TC shall not change on the latch cycle (it was incremented on prior pending cycles).
- Timing requirements
  - Let PC at the start of the first miscompare cycle be PC0 (commonly 0). Latching occurs on the first cycle where PC_prev > rtU.PClimit.
  - If PC0 = 0 and the pattern holds continuously, latch happens on the (rtU.PClimit + 1)-th miscompare frame after onset.
  - All checks at end of cycle (post global step). The UnitDelay is updated after outputs are produced.

[RM-002]
- Initial conditions
  - At cycle k end: rtDW.Merge_e[2] == 0 (No-Fail selected within the same cycle), regardless of rtDW.Merge_e[0] (PC) value.
- Input triggers
  - None beyond FC == 0; selection does not depend on PC in code.
- Expected state changes
  - Selection computation (mid-value) within the cycle:
    - m = ((rtU.ia + rtU.ib) + rtU.ic)/3.0
    - Choose between rtU.ia and rtU.ib the one with smaller |candidate - m|
    - Then choose between that candidate and rtU.ic the one with smaller |candidate - m|
    - rtDW.Merge is set to that value; rtY.sel_val = rtDW.Merge
  - Counters and FC unaffected by selection; they are already set via rtDW.Merge_e.
- Output verification
  - With rtY.FC == 0 at cycle end, rtY.sel_val equals the mid-value of {rtU.ia, rtU.ib, rtU.ic} as produced by the above mean-proximity two-switch procedure.
  - A first failure in progress (rtY.PC > 0) does not change the selection method; FC==0 guarantees mid-value path in code.
- Timing requirements
  - Verified every cycle where rtY.FC == 0. Check after the global step call.

[RM-003]
- Initial conditions
  - Single-fail state at cycle end is indicated by rtY.FC in {1,2,4}.
- Input triggers
  - FC drives selection method:
    - rtY.FC == 1: Single-BranchC-Fail
    - rtY.FC == 2: Single-BranchB-Fail
    - rtY.FC == 4: Single-BranchA-Fail
- Expected state changes
  - rtY.sel_val is Good Channel Average (GCA) of the remaining two good branches:
    - rtY.FC == 1 (C failed): rtY.sel_val = (rtU.ia + rtU.ib)/2.0
    - rtY.FC == 2 (B failed): rtY.sel_val = (rtU.ia + rtU.ic)/2.0
    - rtY.FC == 4 (A failed): rtY.sel_val = (rtU.ib + rtU.ic)/2.0
  - Counters do not change due to selection; they are determined earlier in the monitor logic.
- Output verification
  - For FC==1: rtY.sel_val equals (rtU.ia + rtU.ib)/2.0
  - For FC==2: rtY.sel_val equals (rtU.ia + rtU.ic)/2.0
  - For FC==4: rtY.sel_val equals (rtU.ib + rtU.ic)/2.0
- Timing requirements
  - Verified every cycle with rtY.FC in {1,2,4}. Check after the global step call.

[RM-004]
- Initial conditions
  - One failure already latched: rtY.FC in {1,2,4} at the end of the previous cycle.
- Input triggers (second failure in progress, as represented in code)
  - Code identifies the “all-three miscompare” condition:
    - (fabs(rtU.ia - rtU.ib) > rtU.Tlevel) &&
      (fabs(rtU.ib - rtU.ic) > rtU.Tlevel) &&
      (fabs(rtU.ia - rtU.ic) > rtU.Tlevel)
  - Note: The code does not gate this by FC; it applies regardless of FC. When this condition holds, the code executes “Act8”.
- Expected state changes (actual code behavior)
  - When “all-three miscompare” holds:
    - rtDW.Merge_e[0] = rtDW.Delay1_DSTATE[0]          // PC unchanged
    - rtDW.Merge_e[1] = rtDW.Delay1_DSTATE[1] + 1      // TC increments by 1
    - rtDW.Merge_e[2] = rtDW.Delay1_DSTATE[2]          // FC unchanged
  - Selection behavior under FC persists:
    - rtY.sel_val continues to be computed from current inputs using the method implied by rtY.FC (mid-value if FC==0; GCA if FC in {1,2,4}).
  - Important: The code does not freeze rtY.sel_val to the previous numeric sample; it only keeps FC unchanged. Therefore, the numeric value of rtY.sel_val can change from cycle to cycle as inputs change, even during “second failure in progress”.
- Output verification
  - To check for a freeze per requirement-as-written: compare rtY.sel_val[k] vs rtY.sel_val[k-1] when all-three miscompare is true and rtY.FC != 0. The code does not enforce equality; any equality would only occur if inputs happen not to change accordingly.
  - To check code’s actual implemented behavior: verify that when all-three miscompare holds, rtY.FC remains unchanged and rtY.PC remains unchanged, while rtY.TC increments by 1. rtY.sel_val is recomputed from current inputs per FC.
- Timing requirements
  - Verify after each global step:
    - PC and FC hold their previous values;
    - TC increments by 1 when all three miscompares are true;
    - No special timing window beyond per-cycle check.
  - CLEAR UnitDelay update after global_step(): rtDW.Delay1_DSTATE[...] <= rtDW.Merge_e[...] (so the unchanged PC/FC and incremented TC persist to the next cycle).

3. Timing Considerations
- Update sequences (within each triplex_12B_step)
  - Read previous state from rtDW.Delay1_DSTATE[...] at the start of the function.
  - Compute miscompare booleans and pattern classifications.
  - Execute monitor If-Else chain to produce next state rtDW.Merge_e[...] (PC/TC/FC for this cycle).
  - Drive outputs rtY.PC, rtY.TC, rtY.FC from rtDW.Merge_e.
  - Compute selection rtDW.Merge (and thus rtY.sel_val) based on rtDW.Merge_e[2] (FC) from the same cycle.
  - UnitDelay update (VERY IMPORTANT): after outputs are produced, at the end of the function
    - rtDW.Delay1_DSTATE[0] = rtDW.Merge_e[0]
    - rtDW.Delay1_DSTATE[1] = rtDW.Merge_e[1]
    - rtDW.Delay1_DSTATE[2] = rtDW.Merge_e[2]
- Critical dependencies
  - Latching requires both:
    - A single-branch isolation pattern (A/B/C-fail pattern), and
    - PC_prev > rtU.PClimit at the start of the latching cycle.
  - Pending failure increments (Act4) occur only when a single-branch isolation pattern holds and PC_prev <= rtU.PClimit.
  - “No-miscompare” leads to:
    - If PC_prev == 0: keep PC=0 (Act1).
    - If PC_prev > 0: decrement PC by 1 (Act2).
  - Exactly one-pair miscompare (and the other two within Tlevel) leaves PC/TC/FC unchanged (Act3).
  - “All-three miscompare” increments TC only (Act8); does not change PC or FC; selection method is unchanged because FC is unchanged.
- Cycle requirements
  - Each call to triplex_12B_step is one cycle.
  - All verifications should be performed at the end of the cycle.
  - For RM-001, from first detection of a persistent single-branch isolation pattern with PC_prev=0, latching occurs on the (rtU.PClimit + 1)-th consecutive miscompare frame; the latch sets FC to {1,2,4} according to which branch is isolated and resets PC to 0 in that same cycle.

END OF FILE