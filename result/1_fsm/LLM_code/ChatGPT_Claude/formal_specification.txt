[txt file: fsm_12B_global_analysis.txt]
1. State Variable Mapping
- Variable names, possible values, meanings
  - rtDW.UnitDelay_DSTATE
    - Values: 0.0, 1.0, 2.0, 3.0
    - Meaning (Autopilot previous STATE at cycle start):
      - 0.0 = TRANSITION
      - 1.0 = NOMINAL
      - 2.0 = MANEUVER
      - 3.0 = STANDBY
  - rtDW.Merge
    - Values: 0.0, 1.0, 2.0, 3.0
    - Meaning (Autopilot current STATE computed within the step; drives rtY.STATE):
      - 0.0 = TRANSITION
      - 1.0 = NOMINAL
      - 2.0 = MANEUVER
      - 3.0 = STANDBY
  - rtDW.UnitDelay1_DSTATE
    - Values: 0.0, 1.0, 2.0
    - Meaning (Sensor previous SENSTATE at cycle start):
      - 0.0 = NOMINAL
      - 1.0 = TRANSITION
      - 2.0 = FAULT
  - rtDW.Merge_g
    - Values: 0.0, 1.0, 2.0
    - Meaning (Sensor current SENSTATE computed within the step; drives rtY.SENSTATE):
      - 0.0 = NOMINAL
      - 1.0 = TRANSITION
      - 2.0 = FAULT
  - rtDW.UnitDelay2_DSTATE
    - Values: true, false
    - Meaning (latched “sensor-good” from previous cycle):
      - true  = !(previous rtDW.Merge_g == 2.0) i.e., sensor was NOT in FAULT at end of previous cycle
      - false = (previous rtDW.Merge_g == 2.0) i.e., sensor WAS in FAULT at end of previous cycle
  - rtDW.Merge_p[3]
    - Values: booleans per index
    - Meaning (Autopilot internal moding booleans for current cycle; also used by sensor logic)
      - rtDW.Merge_p[0] = MODE (true in states 1,2,3; false only in state 0)
      - rtDW.Merge_p[1] = REQUEST (true in states 0,1,2; false only in state 3)
      - rtDW.Merge_p[2] = PULL (true only in MANEUVER (state 2); else false)
  - External inputs (rtU.*)
    - rtU.standby: boolean (pilot in control)
    - rtU.apfail: boolean (failure indication)
    - rtU.supported: boolean (system health enable)
    - rtU.limits: boolean (sensor limits exceeded)
  - External outputs (rtY.*)
    - rtY.STATE = rtDW.Merge (Autopilot STATE for current cycle)
    - rtY.SENSTATE = rtDW.Merge_g (Sensor SENSTATE for current cycle)
    - rtY.pullup = rtDW.Merge_p[2] (True when Autopilot in MANEUVER)

- State transitions and conditions (from code)
  - Autopilot (decision uses rtDW.UnitDelay_DSTATE and rtDW.UnitDelay2_DSTATE):
    - From TRANSITION (0.0):
      - if (rtU.standby) -> 3.0 (STANDBY)
      - else if (rtU.supported && rtDW.UnitDelay2_DSTATE) -> 1.0 (NOMINAL)
      - else -> stay 0.0
    - From NOMINAL (1.0):
      - if (rtU.standby) -> 3.0 (STANDBY)
      - else if (!rtDW.UnitDelay2_DSTATE) -> 2.0 (MANEUVER)
      - else -> stay 1.0
    - From MANEUVER (2.0):
      - if (rtU.standby && rtDW.UnitDelay2_DSTATE) -> 3.0 (STANDBY)
      - else if (rtU.supported && rtDW.UnitDelay2_DSTATE) -> 0.0 (TRANSITION)
      - else -> stay 2.0
    - From STANDBY (3.0):
      - if (rtU.apfail) -> 2.0 (MANEUVER)
      - else if (!rtU.standby) -> 0.0 (TRANSITION)
      - else -> stay 3.0
  - Autopilot moding booleans (rtDW.Merge_p) by Autopilot STATE (rtDW.Merge):
    - STATE 0.0 (TRANSITION): [MODE=false, REQUEST=true, PULL=false]
    - STATE 1.0 (NOMINAL):    [MODE=true,  REQUEST=true, PULL=false]
    - STATE 2.0 (MANEUVER):   [MODE=true,  REQUEST=true, PULL=true]
    - STATE 3.0 (STANDBY):    [MODE=true,  REQUEST=false, PULL=false]
  - Sensor (decision uses rtDW.UnitDelay1_DSTATE, rtDW.Merge_p, rtU.limits):
    - From NOMINAL (0.0):
      - if (rtU.limits) -> 2.0 (FAULT)
      - else if (!rtDW.Merge_p[1]) -> 1.0 (TRANSITION)
      - else -> stay 0.0
    - From TRANSITION (1.0):
      - if (rtDW.Merge_p[0] && rtDW.Merge_p[1]) -> 0.0 (NOMINAL)
      - else -> stay 1.0
    - From FAULT (2.0):
      - if ((!rtDW.Merge_p[1]) || (!rtU.limits)) -> 1.0 (TRANSITION)
      - else -> stay 2.0

- Update sequences (within one fsm_12B_global_step call)
  1) Read rtDW.UnitDelay_DSTATE (Autopilot previous STATE) into rtb_UnitDelay.
  2) Compute Autopilot next state rtDW.Merge using rtU.* and rtDW.UnitDelay2_DSTATE.
  3) Compute Autopilot moding booleans rtDW.Merge_p[] from rtDW.Merge.
  4) Read rtDW.UnitDelay1_DSTATE (Sensor previous SENSTATE) into rtb_UnitDelay.
  5) Compute Sensor next state rtDW.Merge_g using rtU.limits and rtDW.Merge_p[].
  6) Drive outputs: rtY.STATE=rtDW.Merge, rtY.SENSTATE=rtDW.Merge_g, rtY.pullup=rtDW.Merge_p[2].
  7) UnitDelay updates (performed AFTER fsm_12B_global_step()):
     - rtDW.UnitDelay_DSTATE <= rtDW.Merge
     - rtDW.UnitDelay1_DSTATE <= rtDW.Merge_g
     - rtDW.UnitDelay2_DSTATE <= !(rtDW.Merge_g == 2.0)
     CLEAR: UnitDelay updates happen after fsm_12B_global_step() and take the values shown above.

2. For each requirement
All checks are performed at cycle end (after fsm_12B_global_step()).

1) Requirement 1: Exceeding sensor limits shall latch an autopilot pullup when the pilot is not in control (not standby) and the system is supported without failures (not apfail).
- Initial conditions
  - Autopilot prior state: rtDW.UnitDelay_DSTATE == 1.0 (NOMINAL) at end of previous cycle (typical path to MANEUVER).
  - Sensor prior state: rtDW.UnitDelay1_DSTATE == 0.0 (NOMINAL).
  - Latched sensor-good from previous cycle: rtDW.UnitDelay2_DSTATE == true.
- Input triggers (applied in cycle k)
  - rtU.limits == true
  - rtU.standby == false
  - rtU.supported == true
  - rtU.apfail == false
- Expected state changes (per code)
  - Cycle k (sensor reacts): rtDW.Merge_g -> 2.0 (FAULT); rtY.SENSTATE == 2.0 at end of k.
  - UnitDelay update after k: rtDW.UnitDelay2_DSTATE <= false (because rtDW.Merge_g == 2.0).
  - Cycle k+1 (autopilot reacts): with !rtDW.UnitDelay2_DSTATE, from NOMINAL the autopilot sets rtDW.Merge -> 2.0 (MANEUVER); rtDW.Merge_p[2] -> true.
  - rtY.STATE == 2.0 and rtY.pullup == true at end of k+1.
  - Latching behavior in code: Once in MANEUVER (rtDW.Merge == 2.0), it stays 2.0 unless rtDW.UnitDelay2_DSTATE == true and (rtU.supported == true -> go to 0.0) or (rtU.standby == true -> go to 3.0). Apfail is not consulted in MANEUVER.
- Output verification
  - rtY.pullup == true and rtY.STATE == 2.0 at end of cycle k+1.
- Timing requirements
  - 1-cycle latency from limits assertion (cycle k) to pullup assertion (cycle k+1) due to use of rtDW.UnitDelay2_DSTATE (latched sensor-good).
  - CLEAR: UnitDelay update after k sets rtDW.UnitDelay2_DSTATE = false, enabling the transition in k+1.

2) Requirement 2: The autopilot shall change states from TRANSITION to STANDBY when the pilot is in control (standby).
- Initial conditions
  - rtDW.UnitDelay_DSTATE == 0.0 (TRANSITION).
- Input triggers
  - rtU.standby == true (in current cycle).
- Expected state changes
  - rtDW.Merge -> 3.0 (STANDBY) in the same cycle; rtY.STATE == 3.0 at end of cycle k.
- Output verification
  - rtY.STATE == 3.0 at cycle end.
- Timing requirements
  - 0 additional cycles; change visible at end of current cycle k.

3) Requirement 3: The autopilot shall change states from TRANSITION to NOMINAL when the system is supported and sensor data is good.
- Initial conditions
  - rtDW.UnitDelay_DSTATE == 0.0 (TRANSITION).
  - rtDW.UnitDelay2_DSTATE == true (sensor-good latched from previous cycle).
- Input triggers
  - rtU.supported == true.
  - rtU.standby == false (implicit as not taking the STANDBY branch).
- Expected state changes
  - rtDW.Merge -> 1.0 (NOMINAL) in the same cycle; rtY.STATE == 1.0 at end of cycle k.
- Output verification
  - rtY.STATE == 1.0 at cycle end.
- Timing requirements
  - 0 additional cycles if rtDW.UnitDelay2_DSTATE is already true. If sensor just became good this cycle, the enabling of rtDW.UnitDelay2_DSTATE occurs after cycle end and the transition occurs in the next cycle.

4) Requirement 4: The autopilot shall change states from NOMINAL to MANEUVER when the sensor data is not good.
- Initial conditions
  - rtDW.UnitDelay_DSTATE == 1.0 (NOMINAL).
  - rtDW.UnitDelay2_DSTATE == false (latched “sensor not good” from previous cycle).
- Input triggers
  - No additional inputs required; ensure rtU.standby == false to avoid STANDBY branch.
- Expected state changes
  - rtDW.Merge -> 2.0 (MANEUVER); rtDW.Merge_p[2] -> true; rtY.STATE == 2.0, rtY.pullup == true at end of cycle k.
- Output verification
  - rtY.STATE == 2.0 and rtY.pullup == true at cycle end.
- Timing requirements
  - 0 additional cycles once rtDW.UnitDelay2_DSTATE is false. If sensor fault occurs this cycle, Autopilot transitions in the next cycle (1-cycle latency).

5) Requirement 5: The autopilot shall change states from NOMINAL to STANDBY when the pilot is in control (standby).
- Initial conditions
  - rtDW.UnitDelay_DSTATE == 1.0 (NOMINAL).
- Input triggers
  - rtU.standby == true.
- Expected state changes
  - rtDW.Merge -> 3.0 (STANDBY); rtY.STATE == 3.0 at end of cycle k.
- Output verification
  - rtY.STATE == 3.0 at cycle end.
- Timing requirements
  - 0 additional cycles; immediate in current cycle.

6) Requirement 6: The autopilot shall change states from MANEUVER to STANDBY when the pilot is in control (standby) and sensor data is good.
- Initial conditions
  - rtDW.UnitDelay_DSTATE == 2.0 (MANEUVER).
  - rtDW.UnitDelay2_DSTATE == true (sensor-good latched from previous cycle).
- Input triggers
  - rtU.standby == true.
- Expected state changes
  - rtDW.Merge -> 3.0 (STANDBY); rtDW.Merge_p[2] -> false; rtY.STATE == 3.0, rtY.pullup == false at end of cycle k.
- Output verification
  - rtY.STATE == 3.0 and rtY.pullup == false at cycle end.
- Timing requirements
  - 0 additional cycles when rtDW.UnitDelay2_DSTATE == true. If sensor becomes good this cycle, transition occurs next cycle due to UnitDelay.

7) Requirement 7: The autopilot shall change states from PULLUP to TRANSITION when the system is supported and sensor data is good.
- Initial conditions
  - rtDW.UnitDelay_DSTATE == 2.0 (MANEUVER, i.e., PULLUP).
  - rtDW.UnitDelay2_DSTATE == true (sensor-good latched).
- Input triggers
  - rtU.supported == true.
  - rtU.standby == false (to avoid STANDBY branch).
- Expected state changes
  - rtDW.Merge -> 0.0 (TRANSITION); rtDW.Merge_p[2] -> false; rtY.STATE == 0.0, rtY.pullup == false at end of cycle k.
- Output verification
  - rtY.STATE == 0.0 and rtY.pullup == false at cycle end.
- Timing requirements
  - 0 additional cycles when rtDW.UnitDelay2_DSTATE == true.

8) Requirement 8: The autopilot shall change states from STANDBY to TRANSITION when the pilot is not in control (not standby).
- Initial conditions
  - rtDW.UnitDelay_DSTATE == 3.0 (STANDBY).
- Input triggers
  - rtU.standby == false.
- Expected state changes
  - rtDW.Merge -> 0.0 (TRANSITION); rtY.STATE == 0.0 at end of cycle k.
- Output verification
  - rtY.STATE == 0.0 at cycle end.
- Timing requirements
  - 0 additional cycles.

9) Requirement 9: The autopilot shall change states from STANDBY to MANEUVER when a failure occurs (apfail).
- Initial conditions
  - rtDW.UnitDelay_DSTATE == 3.0 (STANDBY).
- Input triggers
  - rtU.apfail == true.
- Expected state changes
  - rtDW.Merge -> 2.0 (MANEUVER); rtDW.Merge_p[2] -> true; rtY.STATE == 2.0 and rtY.pullup == true at end of cycle k.
- Output verification
  - rtY.STATE == 2.0 and rtY.pullup == true at cycle end.
- Timing requirements
  - 0 additional cycles.

10) Requirement 10: The sensor shall change states from NOMINAL to FAULT when limits are exceeded.
- Initial conditions
  - rtDW.UnitDelay1_DSTATE == 0.0 (NOMINAL).
- Input triggers
  - rtU.limits == true.
- Expected state changes
  - rtDW.Merge_g -> 2.0 (FAULT); rtY.SENSTATE == 2.0 at end of cycle k.
- Output verification
  - rtY.SENSTATE == 2.0 at cycle end.
- Timing requirements
  - 0 additional cycles.

11) Requirement 11: The sensor shall change states from NOMINAL to TRANSITION when the autopilot is not requesting support (not request).
- Initial conditions
  - rtDW.UnitDelay1_DSTATE == 0.0 (NOMINAL).
- Input triggers
  - Autopilot current request false: rtDW.Merge_p[1] == false (this occurs only when rtDW.Merge == 3.0 STANDBY in the current cycle).
- Expected state changes
  - rtDW.Merge_g -> 1.0 (TRANSITION); rtY.SENSTATE == 1.0 at end of cycle k.
- Output verification
  - rtY.SENSTATE == 1.0 at cycle end.
- Timing requirements
  - 0 additional cycles; sensor uses current-cycle rtDW.Merge_p[1].

12) Requirement 12: The sensor shall change states from FAULT to TRANSITION when the autopilot is not requesting support (not request) and limits are not exceeded (not limits).
- Initial conditions
  - rtDW.UnitDelay1_DSTATE == 2.0 (FAULT).
- Input triggers
  - rtDW.Merge_p[1] == false (not request) AND rtU.limits == false (not limits).
- Expected state changes
  - Per code condition: if ((!rtDW.Merge_p[1]) || (!rtU.limits)) then rtDW.Merge_g -> 1.0 (TRANSITION).
  - Under the specified trigger (both true), the OR condition is satisfied; rtY.SENSTATE == 1.0 at end of cycle k.
- Output verification
  - rtY.SENSTATE == 1.0 at cycle end.
- Timing requirements
  - 0 additional cycles.

13) Requirement 13: The sensor shall change states from TRANSITION to NOMINAL when the autopilot is requesting support (request) and the autopilot reports the correct active mode (mode).
- Initial conditions
  - rtDW.UnitDelay1_DSTATE == 1.0 (TRANSITION).
- Input triggers
  - rtDW.Merge_p[1] == true (request).
  - rtDW.Merge_p[0] == true (mode).
  - Note: In code, both are true when Autopilot current state rtDW.Merge is 1.0 (NOMINAL) or 2.0 (MANEUVER).
- Expected state changes
  - rtDW.Merge_g -> 0.0 (NOMINAL); rtY.SENSTATE == 0.0 at end of cycle k.
- Output verification
  - rtY.SENSTATE == 0.0 at cycle end.
- Timing requirements
  - 0 additional cycles.

3. Timing Considerations
- Update sequences
  - Autopilot next state (rtDW.Merge) is computed using:
    - Autopilot previous state (rtDW.UnitDelay_DSTATE) from prior cycle.
    - Latched sensor-good flag (rtDW.UnitDelay2_DSTATE) from prior cycle.
    - Current inputs rtU.standby, rtU.supported, rtU.apfail.
  - Autopilot moding booleans (rtDW.Merge_p[]) are computed from Autopilot next state in the same cycle.
  - Sensor next state (rtDW.Merge_g) is computed using:
    - Sensor previous state (rtDW.UnitDelay1_DSTATE) from prior cycle.
    - Current rtDW.Merge_p[] (Autopilot current-cycle mode/request).
    - Current rtU.limits.
  - Outputs rtY.STATE, rtY.SENSTATE, rtY.pullup reflect rtDW.Merge, rtDW.Merge_g, rtDW.Merge_p[2] of the current cycle (before UnitDelay updates).

- Critical dependencies
  - Autopilot decisions that depend on sensor health use rtDW.UnitDelay2_DSTATE, which is updated AFTER the step from the current sensor state:
    - CLEAR: rtDW.UnitDelay2_DSTATE is updated after fsm_12B_global_step() with value !(rtDW.Merge_g == 2.0).
    - This introduces a 1-cycle latency from a change in rtU.limits/rtDW.Merge_g to Autopilot reactions that test sensor-good.
  - Sensor decisions depend on Autopilot current-cycle mode/request (rtDW.Merge_p[]), so sensor can respond in the same cycle to Autopilot changes.

- Cycle requirements
  - Verification point: after each fsm_12B_global_step() call.
  - Transitions that depend on rtDW.UnitDelay2_DSTATE (sensor-good) may require one cycle after a sensor state change to become effective in the Autopilot logic.
  - Transitions dependent only on rtU.standby, rtU.supported, rtU.apfail, or rtDW.Merge_p[] occur within the same cycle and are observable at cycle end.

- Explicit UnitDelay updates after fsm_12B_global_step() (VERY IMPORTANT)
  - rtDW.UnitDelay_DSTATE <= rtDW.Merge
  - rtDW.UnitDelay1_DSTATE <= rtDW.Merge_g
  - rtDW.UnitDelay2_DSTATE <= !(rtDW.Merge_g == 2.0)
  - All state checks must use values as observed at the end of the cycle (after the above updates).