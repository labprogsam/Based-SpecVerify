[txt]
1. State Variable Mapping
- Autopilot state (previous): rtDW.UnitDelay_DSTATE
  - Possible values: 0.0, 1.0, 2.0, 3.0
  - Meanings:
    - 0.0 = TRANSITION
    - 1.0 = NOMINAL
    - 2.0 = MANEUVER
    - 3.0 = STANDBY

- Autopilot state (current this cycle): rtDW.Merge
  - Possible values: 0.0, 1.0, 2.0, 3.0
  - Meaning: same encoding as rtDW.UnitDelay_DSTATE; drives rtY.STATE and updates rtDW.UnitDelay_DSTATE at end of cycle

- Autopilot internal discretes (current this cycle): rtDW.Merge_p[3]
  - rtDW.Merge_p[0] (MODE): true except when in TRANSITION (rtDW.Merge == 0.0)
  - rtDW.Merge_p[1] (REQUEST): true in TRANSITION, NOMINAL, MANEUVER; false in STANDBY (i.e., false only when rtDW.Merge == 3.0)
  - rtDW.Merge_p[2] (pullup discrete): true only in MANEUVER (i.e., true only when rtDW.Merge == 2.0)
  - Mapping by autopilot state:
    - TRANSITION (0.0): {false, true,  false}
    - NOMINAL    (1.0): {true,  true,  false}
    - MANEUVER   (2.0): {true,  true,  true}
    - STANDBY    (3.0): {true,  false, false}

- Sensor state (previous): rtDW.UnitDelay1_DSTATE
  - Possible values: 0.0, 1.0, 2.0
  - Meanings:
    - 0.0 = NOMINAL
    - 1.0 = TRANSITION
    - 2.0 = FAULT

- Sensor state (current this cycle): rtDW.Merge_g
  - Possible values: 0.0, 1.0, 2.0
  - Meaning: same encoding as rtDW.UnitDelay1_DSTATE; drives rtY.SENSTATE and updates rtDW.UnitDelay1_DSTATE at end of cycle

- Sensor “good” status seen by Autopilot (previous-cycle derived): rtDW.UnitDelay2_DSTATE
  - Possible values: true, false
  - Meaning: true iff sensor is NOT in FAULT on the previous cycle
  - Update equation at end of cycle: rtDW.UnitDelay2_DSTATE = !(rtDW.Merge_g == 2.0)
  - Note: Autopilot logic uses rtDW.UnitDelay2_DSTATE (one-cycle-delayed view of sensor fault/good)

- External inputs (System External names as in code):
  - rtU.standby (Boolean)
  - rtU.apfail (Boolean)
  - rtU.supported (Boolean)
  - rtU.limits (Boolean)

- External outputs (System External names as in code):
  - rtY.STATE = rtDW.Merge (Autopilot state)
  - rtY.pullup = rtDW.Merge_p[2] (true only when Autopilot in MANEUVER)
  - rtY.SENSTATE = rtDW.Merge_g (Sensor state)

- Initialization:
  - In fsm_12B_global_initialize(): rtDW.UnitDelay_DSTATE = 0.0
  - rtDW.UnitDelay1_DSTATE and rtDW.UnitDelay2_DSTATE are not explicitly initialized in this file; with C static storage they default to 0 (i.e., 0.0 and false respectively) unless set elsewhere

2. Requirements Analysis (code-accurate, cycle-end checks, one requirement per item)

1) Exceeding sensor limits shall latch an autopilot pullup when the pilot is not in control (not standby) and the system is supported without failures (not apfail).
- Initial conditions:
  - Autopilot prior state: rtDW.UnitDelay_DSTATE == 1.0 (NOMINAL) or 0.0/3.0 followed by reaching NOMINAL with request true; practical onset path shown below
  - Sensor prior state (at cycle t0): rtDW.UnitDelay1_DSTATE == 0.0 (NOMINAL)
  - Context per requirement: rtU.standby == false, rtU.supported == true, rtU.apfail == false
- Input triggers:
  - At cycle t0: rtU.limits == true
- Expected state changes:
  - Cycle t0 end:
    - Sensor: rtDW.Merge_g = 2.0 (NOMINAL -> FAULT due to limits)
    - Autopilot: no immediate change from limits; uses previous good status (rtDW.UnitDelay2_DSTATE from t-1)
  - Cycle t1 end:
    - Autopilot: if prior was NOMINAL (rtDW.UnitDelay_DSTATE == 1.0), then !rtDW.UnitDelay2_DSTATE (now false due to FAULT latched at t0) causes rtDW.Merge = 2.0 (NOMINAL -> MANEUVER)
    - Pullup: rtY.pullup = true (since rtDW.Merge == 2.0)
    - Latching: Autopilot remains in MANEUVER (rtDW.Merge stays 2.0) while sensor not good (rtDW.UnitDelay2_DSTATE == false). Exit requires sensor good plus either rtU.supported or rtU.standby per code (see Timing notes).
- Output verification:
  - Cycle t1 end: rtY.STATE == 2.0 and rtY.pullup == true
  - Sensor FAULT at t0 end: rtY.SENSTATE == 2.0
- Timing requirements:
  - One-cycle latency from limits assertion to pullup: t0 (limits true) -> t1 (pullup true)
  - Latch persists until sensor becomes good (rtDW.UnitDelay2_DSTATE == true). Standby/support/apfail do not gate entry into MANEUVER in code; they affect exit paths only.

2) The autopilot shall change states from TRANSITION to STANDBY when the pilot is in control (standby).
- Initial conditions:
  - rtDW.UnitDelay_DSTATE == 0.0 (TRANSITION)
- Input triggers:
  - rtU.standby == true
- Expected state changes:
  - Autopilot: rtDW.Merge = 3.0 (TRANSITION -> STANDBY)
- Output verification:
  - Cycle end: rtY.STATE == 3.0
- Timing requirements:
  - Same-cycle effect (no extra cycle). Check at end of the same fsm_12B_global_step().

3) The autopilot shall change states from TRANSITION to NOMINAL when the system is supported and sensor data is good.
- Initial conditions:
  - rtDW.UnitDelay_DSTATE == 0.0 (TRANSITION)
  - rtDW.UnitDelay2_DSTATE == true (sensor good as of previous cycle)
- Input triggers:
  - rtU.supported == true
- Expected state changes:
  - Autopilot: rtDW.Merge = 1.0 (TRANSITION -> NOMINAL)
- Output verification:
  - Cycle end: rtY.STATE == 1.0
- Timing requirements:
  - Same-cycle effect, provided rtDW.UnitDelay2_DSTATE is already true at cycle start.

4) The autopilot shall change states from NOMINAL to MANEUVER when the sensor data is not good.
- Initial conditions:
  - rtDW.UnitDelay_DSTATE == 1.0 (NOMINAL)
  - rtDW.UnitDelay2_DSTATE == false (sensor not good as of previous cycle)
- Input triggers:
  - No additional inputs required
- Expected state changes:
  - Autopilot: rtDW.Merge = 2.0 (NOMINAL -> MANEUVER)
- Output verification:
  - Cycle end: rtY.STATE == 2.0 and rtY.pullup == true
- Timing requirements:
  - Same-cycle effect relative to rtDW.UnitDelay2_DSTATE. If not-good results from limits becoming true this cycle, the transition occurs next cycle because rtDW.UnitDelay2_DSTATE updates after the cycle.

5) The autopilot shall change states from NOMINAL to STANDBY when the pilot is in control (standby).
- Initial conditions:
  - rtDW.UnitDelay_DSTATE == 1.0 (NOMINAL)
- Input triggers:
  - rtU.standby == true
- Expected state changes:
  - Autopilot: rtDW.Merge = 3.0 (NOMINAL -> STANDBY)
- Output verification:
  - Cycle end: rtY.STATE == 3.0
- Timing requirements:
  - Same-cycle effect.

6) The autopilot shall change states from MANEUVER to STANDBY when the pilot is in control (standby) and sensor data is good.
- Initial conditions:
  - rtDW.UnitDelay_DSTATE == 2.0 (MANEUVER)
  - rtDW.UnitDelay2_DSTATE == true (sensor good as of previous cycle)
- Input triggers:
  - rtU.standby == true
- Expected state changes:
  - Autopilot: rtDW.Merge = 3.0 (MANEUVER -> STANDBY)
- Output verification:
  - Cycle end: rtY.STATE == 3.0 and rtY.pullup == false
- Timing requirements:
  - Same-cycle effect relative to rtDW.UnitDelay2_DSTATE. If sensor becomes good this cycle, transition occurs next cycle.

7) The autopilot shall change states from PULLUP to TRANSITION when the system is supported and sensor data is good.
- Initial conditions:
  - rtDW.UnitDelay_DSTATE == 2.0 (MANEUVER i.e., PULLUP active)
  - rtDW.UnitDelay2_DSTATE == true (sensor good as of previous cycle)
- Input triggers:
  - rtU.supported == true
- Expected state changes:
  - Autopilot: rtDW.Merge = 0.0 (MANEUVER -> TRANSITION)
- Output verification:
  - Cycle end: rtY.STATE == 0.0 and rtY.pullup == false
- Timing requirements:
  - Same-cycle effect relative to rtDW.UnitDelay2_DSTATE.

8) The autopilot shall change states from STANDBY to TRANSITION when the pilot is not in control (not standby).
- Initial conditions:
  - rtDW.UnitDelay_DSTATE == 3.0 (STANDBY)
- Input triggers:
  - rtU.standby == false
- Expected state changes:
  - Autopilot: rtDW.Merge = 0.0 (STANDBY -> TRANSITION)
- Output verification:
  - Cycle end: rtY.STATE == 0.0
- Timing requirements:
  - Same-cycle effect.

9) The autopilot shall change states from STANDBY to MANEUVER when a failure occurs (apfail).
- Initial conditions:
  - rtDW.UnitDelay_DSTATE == 3.0 (STANDBY)
- Input triggers:
  - rtU.apfail == true
- Expected state changes:
  - Autopilot: rtDW.Merge = 2.0 (STANDBY -> MANEUVER)
- Output verification:
  - Cycle end: rtY.STATE == 2.0 and rtY.pullup == true
- Timing requirements:
  - Same-cycle effect.

10) The sensor shall change states from NOMINAL to FAULT when limits are exceeded.
- Initial conditions:
  - rtDW.UnitDelay1_DSTATE == 0.0 (NOMINAL)
- Input triggers:
  - rtU.limits == true
- Expected state changes:
  - Sensor: rtDW.Merge_g = 2.0 (NOMINAL -> FAULT)
- Output verification:
  - Cycle end: rtY.SENSTATE == 2.0
- Timing requirements:
  - Same-cycle effect.

11) The sensor shall change states from NOMINAL to TRANSITION when the autopilot is not requesting support (not request).
- Initial conditions:
  - rtDW.UnitDelay1_DSTATE == 0.0 (NOMINAL)
  - Autopilot current request discrete: rtDW.Merge_p[1] == false
    - Note: In this code, rtDW.Merge_p[1] is false only when rtDW.Merge == 3.0 (Autopilot STANDBY) in the same cycle.
- Input triggers:
  - None beyond rtDW.Merge_p[1] == false
- Expected state changes:
  - Sensor: rtDW.Merge_g = 1.0 (NOMINAL -> TRANSITION)
- Output verification:
  - Cycle end: rtY.SENSTATE == 1.0
- Timing requirements:
  - Same-cycle effect with respect to rtDW.Merge_p[1] of the same cycle.

12) The sensor shall change states from FAULT to TRANSITION when the autopilot is not requesting support (not request) and limits are not exceeded (not limits).
- Initial conditions:
  - rtDW.UnitDelay1_DSTATE == 2.0 (FAULT)
- Input triggers (as implemented in code):
  - Condition in code: (!rtDW.Merge_p[1]) || (!rtU.limits)
    - I.e., FAULT -> TRANSITION occurs if not request OR not limits (logical OR)
- Expected state changes:
  - Sensor: rtDW.Merge_g = 1.0 (FAULT -> TRANSITION) when either of the above is true
- Output verification:
  - Cycle end: rtY.SENSTATE == 1.0
- Timing requirements:
  - Same-cycle effect with respect to rtDW.Merge_p[1] and rtU.limits of the same cycle.

13) The sensor shall change states from TRANSITION to NOMINAL when the autopilot is requesting support (request) and the autopilot reports the correct active mode (mode).
- Initial conditions:
  - rtDW.UnitDelay1_DSTATE == 1.0 (TRANSITION)
- Input triggers:
  - rtDW.Merge_p[1] == true (request)
  - rtDW.Merge_p[0] == true (mode)
- Expected state changes:
  - Sensor: rtDW.Merge_g = 0.0 (TRANSITION -> NOMINAL) when both are true (logical AND)
- Output verification:
  - Cycle end: rtY.SENSTATE == 0.0
- Timing requirements:
  - Same-cycle effect with respect to rtDW.Merge_p[0] and rtDW.Merge_p[1] of the same cycle.

3. Timing Considerations
- Update sequences within fsm_12B_global_step():
  - Read rtDW.UnitDelay_DSTATE into rtb_UnitDelay (Autopilot previous state)
  - Compute Autopilot next state rtDW.Merge using:
    - rtU.standby, rtU.supported, rtU.apfail
    - rtDW.UnitDelay2_DSTATE (sensor good from previous cycle)
  - Read rtDW.UnitDelay1_DSTATE into rtb_UnitDelay (Sensor previous state)
  - Compute Autopilot internal discretes rtDW.Merge_p[] from rtDW.Merge
  - Compute Sensor next state rtDW.Merge_g using:
    - rtU.limits
    - rtDW.Merge_p[0] (mode) and rtDW.Merge_p[1] (request) from this same cycle
  - Drive outputs:
    - rtY.STATE = rtDW.Merge
    - rtY.pullup = rtDW.Merge_p[2]
    - rtY.SENSTATE = rtDW.Merge_g
  - Updates (UnitDelay blocks) AFTER this cycle’s outputs are computed:
    - CLEAR: UnitDelay '<S1>/Unit Delay' is updated after fsm_12B_global_step() with value: rtDW.UnitDelay_DSTATE = rtDW.Merge
    - CLEAR: UnitDelay '<S1>/Unit Delay2' is updated after fsm_12B_global_step() with value: rtDW.UnitDelay2_DSTATE = !(rtDW.Merge_g == 2.0)
    - CLEAR: UnitDelay '<S1>/Unit Delay1' is updated after fsm_12B_global_step() with value: rtDW.UnitDelay1_DSTATE = rtDW.Merge_g

- Critical dependencies:
  - Autopilot decisions depend on rtDW.UnitDelay2_DSTATE (sensor good from the previous cycle). Therefore, changes in sensor fault status (rtU.limits affecting rtDW.Merge_g) influence Autopilot transitions one cycle later.
  - Sensor decisions depend on rtDW.Merge_p[0] and rtDW.Merge_p[1] computed from the current Autopilot state of the same cycle.

- Cycle requirements:
  - Checks must be made at cycle end (after fsm_12B_global_step() returns).
  - For requirements involving sensor→autopilot coupling (use of rtDW.UnitDelay2_DSTATE), allow one-cycle latency between a change in rtU.limits/rtY.SENSTATE and the resulting Autopilot transition.
  - For requirements involving autopilot→sensor coupling (use of rtDW.Merge_p[]), effects are visible in the same cycle.

[/txt]